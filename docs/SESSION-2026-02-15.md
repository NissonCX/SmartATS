# SmartATS 开发会话记录 - 2026-02-15

## 会话概览

**日期**: 2026-02-15
**开发阶段**: 认证模块完善 - 邮箱验证码功能
**主要成果**:
1. 理解 JWT Token 认证机制
2. 解决 Spring Security 403 错误
3. 深入理解 Spring Boot context-path
4. 完成邮箱验证码功能实现
5. 代码提交并推送到远程仓库

---

## 一、JWT Token 认证机制深入理解

### 1.1 Token 组成部分

#### accessToken（访问令牌）
- **作用**: 用于访问受保护的 API 资源
- **有效期**: 较短（本项目为 2 小时 = 7200 秒）
- **包含信息**: userId, username, role, 过期时间
- **使用方式**: 放在 HTTP Header 中 `Authorization: Bearer {accessToken}`
- **安全特性**: 过期后需要重新登录或使用 refreshToken 刷新

#### refreshToken（刷新令牌）
- **作用**: 用于获取新的 accessToken，无需重新登录
- **有效期**: 较长（本项目为 7 天 = 604800 秒）
- **存储位置**: 服务端 Redis 中（支持令牌撤销）
- **使用场景**: accessToken 过期时，客户端用 refreshToken 换取新的 accessToken
- **安全优势**:
  - 减少 password 传输次数
  - 可以在服务端撤销（删除 Redis 中的记录）
  - 被盗时危害相对较小（相比长期有效的 accessToken）

#### expiresIn（过期时间）
- **含义**: accessToken 的有效期（秒）
- **用途**: 客户端据此判断何时需要刷新 token
- **计算**: `new Date().getTime() + expiresIn * 1000`

### 1.2 认证流程图

```
┌─────────────┐                    ┌──────────────┐
│   Client    │                    │    Server    │
└──────┬──────┘                    └──────┬───────┘
       │                                   │
       │  1. POST /auth/login              │
       │  {username, password}             │
       │──────────────────────────────────>│
       │                                   │
       │                         2. 验证密码 │
       │                                   │
       │  3. 返回 Token 响应                │
       │  {accessToken, refreshToken,      │
       │   expiresIn, userInfo}            │
       │<──────────────────────────────────│
       │                                   │
       │  4. 存储 tokens                   │
       │                                   │
       │  5. 访问受保护 API                 │
       │  GET /api/v1/jobs                 │
       │  Header: Authorization: Bearer... │
       │──────────────────────────────────>│
       │                                   │
       │                         6. 验证 token │
       │                         7. 返回数据 │
       │<──────────────────────────────────│
       │                                   │
       │  8. Token 过期后刷新               │
       │  POST /auth/refresh-token         │
       │  {refreshToken}                   │
       │──────────────────────────────────>│
       │                                   │
       │  9. 返回新的 accessToken           │
       │<──────────────────────────────────│
```

### 1.3 安全最佳实践

1. **Token 存储位置**:
   - 推荐: HttpOnly Cookie (防止 XSS)
   - 可选: 内存/LocalStorage (需要防范 XSS)

2. **Token 传输**:
   - 必须: HTTPS 加密传输
   - Header: `Authorization: Bearer {token}`

3. **Token 刷新策略**:
   - accessToken 短期有效（1-2 小时）
   - refreshToken 长期有效（7-30 天）
   - refreshToken 存储在 Redis（支持撤销）

---

## 二、Spring Security 403 错误排查与修复

### 2.1 问题描述

**现象**: 所有 API 请求返回 403 Forbidden

**错误日志**:
```
2024-02-15 23:00:00.123  ---nio-8080-exec-1| .a.c.c.JettyConfigurer$ForwardedHeaderFilter
INFO  : Filter mapping not found for /api/v1/auth/register

2024-02-15 23:00:00.456  ---nio-8080-exec-1| o.s.s.w.a.i.FilterSecurityInterceptor
DEBUG: Unauthorized: org.springframework.security.access.AccessDeniedException:
```

### 2.2 问题根源

#### 问题 1: 使用了废弃的 API
```java
// ❌ 错误写法（Spring Security 5.x）
http.authorizeRequests()
    .antMatchers("/auth/register").permitAll();

// ✅ 正确写法（Spring Security 6.x）
http.authorizeHttpRequests()
    .requestMatchers("/auth/register").permitAll();
```

**原因**:
- Spring Security 6.x 废弃了 `authorizeRequests()` 方法
- 必须使用 `authorizeHttpRequests()`
- `antMatchers()` 改为 `requestMatchers()`
- `anyRequest()` 改为 `anyRequest()`

#### 问题 2: 路径配置错误
```java
// ❌ 错误：包含了 context-path
.requestMatchers("/api/v1/auth/register").permitAll()

// ✅ 正确：不包含 context-path
.requestMatchers("/auth/register").permitAll()
```

**原因**:
- Tomcat 在请求到达 Spring Security 之前会先处理 context-path
- Spring Security 看到的路径已经去掉了 `/api/v1` 前缀
- 配置路径时不需要包含 context-path

### 2.3 请求处理流程

```
┌─────────────────────────────────────────────────────────┐
│  客户端请求: POST http://localhost:8080/api/v1/auth/register
└─────────────────────┬───────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────┐
│  Tomcat 处理 context-path                                │
│  原始路径: /api/v1/auth/register                         │
│  去掉 context-path 后: /auth/register                   │
│  转发给 Spring MVC 的路径: /auth/register               │
└─────────────────────┬───────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────┐
│  Filter Chain (DelegatingFilterProxy)                   │
│  ↓                                                        │
│  1. SecurityContextPersistenceFilter                    │
│  2. LogoutFilter                                        │
│  3. UsernamePasswordAuthenticationFilter               │
│  4. DefaultLoginPageGeneratingFilter                   │
│  5. FilterSecurityInterceptor ← 这里检查权限            │
│     - 检查路径: /auth/register (不是 /api/v1/auth/register) │
│     - 查找匹配规则: permitAll()                         │
│     - 允许通过 ✅                                        │
└─────────────────────┬───────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────┐
│  DispatcherServlet → AuthController.register()         │
└─────────────────────────────────────────────────────────┘
```

### 2.4 修复后的 SecurityConfig

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // 禁用 CSRF（JWT 不需要）
            .csrf(AbstractHttpConfigurer::disable)

            // 配置会话管理为无状态（JWT）
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )

            // 配置请求授权（Spring Security 6.x 方式）
            .authorizeHttpRequests(auth -> auth
                .requestMatchers(HttpMethod.POST, "/auth/register").permitAll()
                .requestMatchers(HttpMethod.POST, "/auth/login").permitAll()
                .requestMatchers(HttpMethod.POST, "/auth/send-verification-code").permitAll()
                .anyRequest().authenticated()
            );

        return http.build();
    }
}
```

**关键点**:
1. ✅ 使用 `authorizeHttpRequests()` 而非 `authorizeRequests()`
2. ✅ 路径不包含 context-path
3. ✅ 使用 `requestMatchers()` 而非 `antMatchers()`
4. ✅ 配置 `SessionCreationPolicy.STATELESS`（为 JWT 做准备）

### 2.5 经验教训

**"先打开'门'，再进'屋'"**:
1. 第一步：确保 SecurityConfig 放行所有需要公开访问的路径（"打开门"）
2. 第二步：实现业务逻辑和 JWT Filter（"进屋"）
3. 调试顺序：Security → Controller → Service → Mapper

**Spring Security 6.x 迁移要点**:
| Spring Security 5.x | Spring Security 6.x |
|---------------------|---------------------|
| `authorizeRequests()` | `authorizeHttpRequests()` |
| `antMatchers()` | `requestMatchers()` |
| `mvcMatchers()` | `requestMatchers()` |
| `regexMatchers()` | `requestMatchers()` |

---

## 三、Spring Boot Context-Path 深入理解

### 3.1 什么是 Context-Path？

**Context-Path** 是 Spring Boot 应用的全局路径前缀，所有请求都必须以这个路径开头。

**配置示例**:
```yaml
server:
  servlet:
    context-path: /api/v1
```

### 3.2 为什么需要 Context-Path？

#### 1. 系统隔离（多系统共存）

**场景**: 一个域名下运行多个系统

```
https://example.com/
├── /api/v1/auth       (SmartATS 招聘系统)
├── /api/v2/auth       (SmartATS v2 新版本)
├── /api/hr/auth       (HR 管理系统)
├── /api/oa/auth       (OA 办公系统)
└── /api/crm/auth      (CRM 客户系统)
```

**优势**:
- 同一台服务器运行多个应用
- 使用同一个域名（节省成本）
- 通过路径区分不同系统
- 便于 API 版本管理（v1, v2 共存）

#### 2. API 版本管理

```yaml
# v1 版本（旧版，仍在维护）
server:
  servlet:
    context-path: /api/v1

# v2 版本（新版，最新功能）
server:
  servlet:
    context-path: /api/v2
```

**迁移策略**:
- v1 保持稳定（不接受新功能）
- v2 添加新功能
- 逐步将客户端从 v1 迁移到 v2
- 最终 v1 下线

#### 3. 部署灵活性

**开发环境**:
```yaml
server:
  servlet:
    context-path: /
  port: 8080
```
访问: `http://localhost:8080/auth/login`

**生产环境**:
```yaml
server:
  servlet:
    context-path: /api/v1
  port: 8080
```
访问: `http://prod.example.com/api/v1/auth/login`

#### 4. 反向代理配置

**Nginx 配置示例**:
```nginx
# 招聘系统
location /api/v1/ {
    proxy_pass http://localhost:8080/api/v1/;
}

# HR 系统
location /api/hr/ {
    proxy_pass http://localhost:8081/api/hr/;
}

# OA 系统
location /api/oa/ {
    proxy_pass http://localhost:8082/api/oa/;
}
```

### 3.3 Context-Path 处理流程

```
┌────────────────────────────────────────────┐
│  完整 URL:                                  │
│  http://localhost:8080/api/v1/auth/login   │
└────────────┬───────────────────────────────┘
             │
             ▼
┌────────────────────────────────────────────┐
│  URL 分解:                                  │
│  - protocol: http://                       │
│  - host: localhost                         │
│  - port: 8080                              │
│  - context-path: /api/v1                   │
│  - servlet-path: /auth/login               │
└────────────┬───────────────────────────────┘
             │
             ▼
┌────────────────────────────────────────────┐
│  Tomcat 处理:                               │
│  1. 去掉 protocol://host:port              │
│     → /api/v1/auth/login                   │
│  2. 识别并去掉 context-path                │
│     → /auth/login                          │
│  3. 转发给 Spring MVC                      │
└────────────┬───────────────────────────────┘
             │
             ▼
┌────────────────────────────────────────────┐
│  Spring MVC:                                │
│  @RequestMapping("/auth/login")             │
│  → 匹配成功 ✅                              │
└────────────────────────────────────────────┘
```

### 3.4 代码中的路径配置原则

#### Controller 层（不需要包含 context-path）
```java
@RestController
@RequestMapping("/auth")  // ❌ 不是 "/api/v1/auth"
public class AuthController {

    @PostMapping("/register")  // ❌ 不是 "/api/v1/auth/register"
    public Result<Void> register(@RequestBody RegisterRequest request) {
        // ...
    }
}
```

**原因**: Spring MVC 看到的路径已经由 Tomcat 去掉了 context-path

#### SecurityConfig 层（不需要包含 context-path）
```java
.requestMatchers("/auth/register").permitAll()  // ❌ 不是 "/api/v1/auth/register"
```

**原因**: Spring Security 在 Filter Chain 中，路径也已去掉 context-path

#### 前端请求（需要包含 context-path）
```javascript
// ✅ 正确：包含完整的 context-path
fetch('http://localhost:8080/api/v1/auth/register', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username: 'test', password: '123' })
})
```

### 3.5 总结

**Context-Path 是"虚拟路径前缀"**:
- Tomcat 层面处理（在 Spring Security 之前）
- 对 Spring Boot 内部透明（Controller、Service 都感知不到）
- 前端请求时必须包含
- 内部配置时不需要包含

**记忆口诀**:
> "对外（前端）要带，对内（代码）不带"

---

## 四、邮箱验证码功能实现

### 4.1 功能需求

用户提出的改进需求：
> "我对现有注册接口功能还不是特别满意，我期望添加邮箱验证码验证功能。"

**具体要求**:
1. 6 位数字验证码
2. 5 分钟过期（300 秒）
3. 防刷限制：60 秒内只能发送一次
4. 发送前检查邮箱是否已注册
5. 一次性使用（验证成功后删除）

### 4.2 架构设计

```
┌──────────────┐                     ┌──────────────┐
│   Client     │                     │    Server    │
└──────┬───────┘                     └──────┬───────┘
       │                                     │
       │ 1. POST /auth/send-verification-code
       │    {email: "test@example.com"}      │
       │────────────────────────────────────>│
       │                                     │
       │                            2. 检查邮箱是否已注册
       │                                     │
       │                            3. 检查防刷限制（Redis）
       │                                     │
       │                            4. 生成 6 位验证码
       │                                     │
       │                            5. 存储到 Redis（5分钟）
       │                                     │
       │                            6. 发送邮件（QQ SMTP）
       │                                     │
       │ 7. 返回成功                          │
       │<────────────────────────────────────│
       │                                     │
       │ 8. 用户查看邮箱获取验证码            │
       │                                     │
       │ 9. POST /auth/register              │
       │    {username, password,             │
       │     email, verificationCode}        │
       │────────────────────────────────────>│
       │                                     │
       │                           10. 验证验证码（Redis）
       │                                     │
       │                           11. 删除验证码（一次性）
       │                                     │
       │                           12. 创建用户
       │                                     │
       │ 13. 返回成功                         │
       │<────────────────────────────────────│
```

### 4.3 核心实现

#### 1. EmailService.java（邮件发送服务）

**功能**:
- 发送 HTML 格式的验证码邮件
- 使用 QQ 邮箱 SMTP 服务
- 显示验证码过期时间

**关键代码**:
```java
@Service
@RequiredArgsConstructor
public class EmailService {

    private final JavaMailSender mailSender;

    @Value("${spring.mail.username}")
    private String fromEmail;

    public boolean sendVerificationCode(String to, String code) {
        MimeMessage message = mailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, true);

        helper.setFrom(fromEmail);
        helper.setTo(to);
        helper.setSubject("【SmartATS】注册验证码");

        String content = buildEmailContent(code);
        helper.setText(content, true);  // true = HTML 格式

        mailSender.send(message);
        return true;
    }

    private String buildEmailContent(String code) {
        int expireMinutes = expireTimeSeconds / 60;

        return """
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; }
                    .code { font-size: 32px; font-weight: bold;
                            color: #667eea; text-align: center;
                            padding: 20px; background: white;
                            border-radius: 5px; }
                </style>
            </head>
            <body>
                <div class="code">%s</div>
                <p>验证码有效期为 <strong>%d 分钟</strong></p>
            </body>
            </html>
            """.formatted(code, expireMinutes);
    }
}
```

**依赖**:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
```

**配置**:
```yaml
spring:
  mail:
    host: smtp.qq.com
    port: 587
    username: 2144546224@qq.com
    password: tpjdvfieotyfebdh  # QQ 邮箱授权码
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
        ssl:
          trust: smtp.qq.com
    default-encoding: UTF-8
```

#### 2. VerificationCodeService.java（验证码服务）

**功能**:
1. 检查邮箱是否已注册
2. 检查防刷限制（60 秒）
3. 生成 6 位随机验证码
4. 存储到 Redis（5 分钟过期）
5. 验证验证码（一次性使用）

**关键代码**:
```java
@Service
@RequiredArgsConstructor
public class VerificationCodeService {

    private final EmailService emailService;
    private final StringRedisTemplate redisTemplate;
    private final UserMapper userMapper;

    // Redis Key 前缀
    private static final String CODE_KEY_PREFIX = "verification_code:";
    private static final String LIMIT_KEY_PREFIX = "verification_code_limit:";

    // 验证码长度
    private static final int CODE_LENGTH = 6;

    // 过期时间
    private static final long CODE_EXPIRE_SECONDS = 300;  // 5 分钟
    private static final long LIMIT_EXPIRE_SECONDS = 60;   // 60 秒

    public void sendVerificationCode(String email) {
        // 第 1 步：检查邮箱是否已注册 ✅ 新增
        Long emailCount = userMapper.selectCount(
            new LambdaQueryWrapper<User>().eq(User::getEmail, email)
        );
        if (emailCount > 0) {
            throw new BusinessException(ResultCode.EMAIL_ALREADY_EXISTS);
        }

        // 第 2 步：检查防刷限制
        String limitKey = LIMIT_KEY_PREFIX + email;
        Boolean isLimited = redisTemplate.hasKey(limitKey);
        if (Boolean.TRUE.equals(isLimited)) {
            throw new BusinessException(ResultCode.VERIFICATION_CODE_SEND_TOO_FREQUENT);
        }

        // 第 3 步：生成 6 位随机验证码
        String code = generateCode();

        // 第 4 步：存储验证码到 Redis（5 分钟过期）
        String codeKey = CODE_KEY_PREFIX + email;
        redisTemplate.opsForValue().set(
            codeKey, code, CODE_EXPIRE_SECONDS, TimeUnit.SECONDS
        );

        // 第 5 步：存储防刷标记（60 秒过期）
        redisTemplate.opsForValue().set(
            limitKey, "1", LIMIT_EXPIRE_SECONDS, TimeUnit.SECONDS
        );

        // 第 6 步：发送邮件
        emailService.sendVerificationCode(email, code);
    }

    public boolean verifyCode(String email, String code) {
        String codeKey = CODE_KEY_PREFIX + email;
        String storedCode = redisTemplate.opsForValue().get(codeKey);

        if (storedCode == null) {
            return false;  // 验证码不存在或已过期
        }

        boolean isValid = storedCode.equals(code);

        if (isValid) {
            // 验证成功后删除验证码（一次性使用）
            redisTemplate.delete(codeKey);
        }

        return isValid;
    }

    private String generateCode() {
        Random random = new Random();
        StringBuilder code = new StringBuilder();
        for (int i = 0; i < CODE_LENGTH; i++) {
            code.append(random.nextInt(10));  // 0-9 随机数字
        }
        return code.toString();
    }
}
```

**Redis 数据结构**:
```
# 验证码存储（5 分钟过期）
verification_code:test@example.com
  → "123456"
  → TTL: 300 秒

# 防刷限制（60 秒过期）
verification_code_limit:test@example.com
  → "1"
  → TTL: 60 秒
```

#### 3. UserService.java（注册流程更新）

**新增验证码校验**:
```java
@Transactional(rollbackFor = Exception.class)
public void register(RegisterRequest request) {
    // 第 0 步：验证邮箱验证码 ✅ 新增
    boolean codeValid = verificationCodeService.verifyCode(
        request.getEmail(),
        request.getVerificationCode()
    );
    if (!codeValid) {
        throw new BusinessException(ResultCode.VERIFICATION_CODE_INVALID);
    }

    // 第 1 步：校验用户名是否已存在
    // ...（原有逻辑）
}
```

#### 4. AuthController.java（新增接口）

```java
@PostMapping("/send-verification-code")
public Result<Void> sendVerificationCode(
    @Valid @RequestBody SendVerificationCodeRequest request
) {
    verificationCodeService.sendVerificationCode(request.getEmail());
    return Result.success();
}
```

#### 5. DTO 更新

**SendVerificationCodeRequest.java**:
```java
@Data
public class SendVerificationCodeRequest {

    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;
}
```

**RegisterRequest.java**:
```java
@Data
public class RegisterRequest {

    // ... 原有字段

    @NotBlank(message = "验证码不能为空")
    @Pattern(regexp = "^\\d{6}$", message = "验证码必须是 6 位数字")
    private String verificationCode;
}
```

#### 6. ResultCode.java（错误码定义）

```java
// ========== 验证码相关错误 11xxx ==========
VERIFICATION_CODE_SEND_TOO_FREQUENT(11001, "验证码发送过于频繁，请稍后再试"),
VERIFICATION_CODE_SEND_FAILED(11002, "验证码发送失败，请稍后重试"),
VERIFICATION_CODE_INVALID(11003, "验证码错误或已过期"),
VERIFICATION_CODE_REQUIRED(11004, "请先获取验证码"),
```

### 4.4 安全优化（用户建议）

**问题**: 一个邮箱只能注册一个账户，发送验证码前应该检查邮箱是否已被注册。

**优化方案**: 在 `VerificationCodeService.sendVerificationCode()` 开头添加邮箱检查：

```java
// 第 1 步：检查邮箱是否已注册 ✅ 新增
Long emailCount = userMapper.selectCount(
    new LambdaQueryWrapper<User>().eq(User::getEmail, email)
);
if (emailCount > 0) {
    throw new BusinessException(ResultCode.EMAIL_ALREADY_EXISTS);
}
```

**优势**:
1. 防止对已注册邮箱发送验证码（避免骚扰）
2. 节省邮件服务和 Redis 资源
3. 提前告知用户邮箱已被占用（提升体验）

### 4.5 配置文件更新

**application.yml**:
```yaml
spring:
  mail:
    host: smtp.qq.com
    port: 587
    username: 2144546224@qq.com
    password: tpjdvfieotyfebdh
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
        ssl:
          trust: smtp.qq.com
    default-encoding: UTF-8

smartats:
  verification-code:
    expire-time: 300  # 验证码过期时间（5分钟 = 300秒）
```

**pom.xml**:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
```

### 4.6 测试方法

#### 1. 发送验证码
```bash
curl -X POST http://localhost:8080/api/v1/auth/send-verification-code \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com"}'
```

**预期响应**:
```json
{
  "code": 200,
  "message": "操作成功",
  "data": null,
  "timestamp": 1704067200000
}
```

#### 2. 查看 Redis 验证码
```bash
# 连接 Redis
redis-cli -h 127.0.0.1 -p 6379 -a redis123

# 查看验证码
127.0.0.1:6379> GET verification_code:test@example.com
"123456"

# 查看过期时间
127.0.0.1:6379> TTL verification_code:test@example.com
(integer) 295  # 剩余秒数

# 查看防刷限制
127.0.0.1:6379> GET verification_code_limit:test@example.com
"1"
```

#### 3. 使用验证码注册
```bash
curl -X POST http://localhost:8080/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "password": "Password123!",
    "email": "test@example.com",
    "verificationCode": "123456",
    "role": "HR"
  }'
```

#### 4. 测试场景

| 场景 | 请求 | 预期结果 |
|------|------|----------|
| 对已注册邮箱发送验证码 | 已注册邮箱 | 返回 10004 "邮箱已被注册" |
| 60 秒内重复发送验证码 | 同一邮箱 | 返回 11001 "验证码发送过于频繁" |
| 使用错误验证码注册 | 错误验证码 | 返回 11003 "验证码错误或已过期" |
| 使用过期验证码注册 | 过期验证码 | 返回 11003 "验证码错误或已过期" |
| 正常注册流程 | 正确验证码 | 注册成功，验证码被删除 |

---

## 五、代码规范与重构

### 5.1 删除冗余文件

**问题**: 发现 `VerificationCodeServices.java`（复数）是冗余文件

**原因**: 之前创建时命名错误，后来创建了正确的 `VerificationCodeService.java`

**解决**: 删除冗余文件
```bash
rm src/main/java/com/smartats/module/auth/service/VerificationCodeServices.java
```

### 5.2 命名规范

**Java 类命名**: 使用单数形式
- ✅ `VerificationCodeService`
- ❌ `VerificationCodeServices`

**原因**:
- 单数表示"一个服务"
- 复数通常用于集合类或控制器
- 符合 Java 命名约定

### 5.3 代码注释风格

**使用分隔线标注步骤**:
```java
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 第 1 步：检查邮箱是否已注册
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Long emailCount = userMapper.selectCount(
    new LambdaQueryWrapper<User>().eq(User::getEmail, email)
);
if (emailCount > 0) {
    throw new BusinessException(ResultCode.EMAIL_ALREADY_EXISTS);
}
```

**优势**:
1. 清晰标注代码逻辑步骤
2. 便于快速定位问题
3. 提升代码可读性

---

## 六、Git 提交与推送

### 6.1 提交信息

```
feat: 实现邮箱验证码功能增强注册安全性

- 新增 EmailService 支持 QQ 邮箱 SMTP 验证码发送
- 新增 VerificationCodeService 实现验证码生成、存储、校验
  - 6位数字验证码，5分钟过期
  - Redis 存储验证码和防刷限制（60秒）
  - 发送前检查邮箱是否已注册
  - 一次性使用（验证成功后删除）
- 更新 UserService 注册流程增加验证码校验
- 更新 AuthController 新增 /send-verification-code 接口
- 更新 RegisterRequest DTO 添加验证码字段
- 更新 ResultCode 添加验证码相关错误码（11xxx）
- 更新 SecurityConfig 添加验证码接口白名单
- 更新 application.yml 添加邮件和验证码配置
- 更新 pom.xml 添加 spring-boot-starter-mail 依赖

Co-Authored-By: Claude (claude-4.5-sonnet) <noreply@anthropic.com>
```

### 6.2 提交统计

**提交 ID**: `37ee833`
**文件变更**: 10 个文件
- 新增: 4 个文件
- 修改: 6 个文件
- 删除: 1 个文件（冗余文件）
- 新增代码: 398 行
- 删除代码: 27 行

### 6.3 远程仓库

```
github.com:NissonCX/SmartATS.git
分支: main
提交: 653519b..37ee833
```

---

## 七、遇到的问题与解决方案

### 7.1 MimeMessage 导入错误

**问题**:
```
Cannot resolve symbol 'MimeMessage'
```

**原因**:
- Spring Boot 3.x 使用 Jakarta EE，不再是 Java EE
- 需要使用 `jakarta.mail` 而非 `javax.mail`

**解决**:
```java
// ❌ 错误
import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;

// ✅ 正确
import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
```

### 7.2 重复 catch 块

**问题**:
```java
try {
    // ...
} catch (MessagingException e) {  // javax.mail.MessagingException
    return false;
} catch (MessagingException e) {  // jakarta.mail.MessagingException
    return false;
}
```

**解决**: 删除重复的 catch 块，只保留正确的 `jakarta.mail.MessagingException`

### 7.3 数据库连接字符编码错误

**问题**:
```
Unsupported character encoding 'utf8mb4'
```

**原因**:
- JDBC 连接字符串使用 Java 字符集名称
- MySQL 使用 `utf8mb4`，但 Java 使用 `UTF-8`

**解决**:
```yaml
# ❌ 错误
url: jdbc:mysql://localhost:3307/smartats?useSSL=false&serverTimezone=Asia/Shanghai&characterEncoding=utf8mb4

# ✅ 正确
url: jdbc:mysql://localhost:3307/smartats?useSSL=false&serverTimezone=Asia/Shanghai&characterEncoding=UTF-8

# ✅ 或者省略（默认就是 UTF-8）
url: jdbc:mysql://localhost:3307/smartats?useSSL=false&serverTimezone=Asia/Shanghai
```

### 7.4 类名不匹配

**问题**:
```
Cannot resolve class 'VerificationCodeServices'
```

**原因**: AuthController 中使用了复数类名

**解决**: 修改为正确的单数类名
```java
// ❌ 错误
private final VerificationCodeServices verificationCodeServices;

// ✅ 正确
private final VerificationCodeService verificationCodeService;
```

---

## 八、技术知识点总结

### 8.1 Spring Boot 3.x 主要变化

1. **Jakarta EE 迁移**
   - `javax.*` → `jakarta.*`
   - 影响：Mail, Validation, Persistence 等

2. **Spring Security 6.x**
   - `authorizeRequests()` → `authorizeHttpRequests()`
   - `antMatchers()` → `requestMatchers()`

3. **Property 变更**
   - `spring.mail.*` 配置保持不变
   - 新增 `server.servlet.context-path`（之前是 `server.context-path`）

### 8.2 Redis Key 设计原则

1. **使用前缀分类**
   ```
   verification_code:     # 验证码
   verification_code_limit:  # 防刷限制
   task:resume:           # 任务状态
   rate:ai:               # 限流
   cache:                 # 缓存
   ```

2. **包含业务标识**
   ```
   verification_code:{email}  # 包含邮箱
   task:resume:{taskId}       # 包含任务ID
   ```

3. **设置合理的 TTL**
   - 验证码: 5 分钟
   - 防刷限制: 60 秒
   - 任务状态: 24 小时
   - 缓存: 30 分钟

### 8.3 邮件发送最佳实践

1. **使用授权码而非密码**
   - QQ 邮箱: 使用 `smtp.qq.com` + 授权码
   - 不使用账户密码（提高安全性）

2. **HTML 邮件模板**
   - 使用 CSS 提升视觉效果
   - 包含品牌标识
   - 清晰显示验证码

3. **错误处理**
   - 捕获 `MessagingException`
   - 记录详细日志
   - 返回失败信息

### 8.4 安全设计原则

1. **最小权限原则**
   - SecurityConfig 只放行必要的公开接口
   - 其他接口需要认证

2. **防刷机制**
   - 验证码: 60 秒限制
   - 使用 Redis TTL 自动过期

3. **一次性使用**
   - 验证码验证成功后立即删除
   - 防止重复使用

4. **提前校验**
   - 发送验证码前检查邮箱是否已注册
   - 避免无效操作

---

## 九、下一步计划

### 9.1 待完成功能

1. **JWT 认证过滤器**
   - 实现 `JwtAuthenticationFilter`
   - 从 Header 中提取并验证 Token
   - 将用户信息存入 SecurityContext

2. **Token 刷新接口**
   - 实现 `/auth/refresh-token` 接口
   - 验证 refreshToken
   - 返回新的 accessToken

3. **退出登录接口**
   - 实现 `/auth/logout` 接口
   - 将 refreshToken 加入黑名单（Redis）

4. **岗位管理模块**
   - Job CRUD 接口
   - Redis 缓存集成
   - 岗位搜索功能

### 9.2 测试计划

1. **单元测试**
   - UserService 测试
   - VerificationCodeService 测试
   - EmailService 测试（使用 Mock）

2. **集成测试**
   - 完整注册流程测试
   - 验证码发送和验证测试
   - Spring Security 配置测试

3. **API 测试**
   - 使用 Postman/Apifox 测试所有接口
   - 验证错误处理
   - 测试边界条件

### 9.3 文档更新

1. **API 文档**
   - 使用 Swagger/OpenAPI 生成 API 文档
   - 添加请求/响应示例

2. **开发文档**
   - 更新 `SmartATS-从0到1开发教学手册.md`
   - 添加邮箱验证码章节
   - 更新 Spring Security 配置说明

---

## 十、参考资料

### 10.1 官方文档

- [Spring Boot 3.x Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/)
- [Spring Security 6.x Documentation](https://docs.spring.io/spring-security/reference/current/index.html)
- [Jakarta Mail API](https://jakarta.ee/specifications/mail/2.0/apidocs/)

### 10.2 相关技术

- [QQ 邮箱 SMTP 设置](https://service.mail.qq.com/cgi-bin/help?subtype=1&id=28&no=1001256)
- [Redis 命令参考](https://redis.io/commands/)
- [MyBatis-Plus 官方文档](https://baomidou.com/)

### 10.3 项目文档

- `docs/SmartATS-Design-Document.md` - 系统设计文档
- `docs/SmartATS-从0到1开发教学手册.md` - 开发教程
- `CLAUDE.md` - 项目指南

---

## 附录：完整的 API 接口列表

### 认证模块（/api/v1/auth）

| 接口 | 方法 | 路径 | 说明 |
|------|------|------|------|
| 用户注册 | POST | /auth/register | 注册新用户（需要验证码） |
| 用户登录 | POST | /auth/login | 用户登录获取 Token |
| 发送验证码 | POST | /auth/send-verification-code | 发送邮箱验证码 |
| 刷新 Token | POST | /auth/refresh-token | 刷新访问令牌（待实现） |
| 退出登录 | POST | /auth/logout | 退出登录（待实现） |

### 请求/响应示例

#### 发送验证码
```bash
POST /api/v1/auth/send-verification-code
Content-Type: application/json

{
  "email": "test@example.com"
}

Response:
{
  "code": 200,
  "message": "操作成功",
  "data": null,
  "timestamp": 1704067200000
}
```

#### 用户注册（带验证码）
```bash
POST /api/v1/auth/register
Content-Type: application/json

{
  "username": "testuser",
  "password": "Password123!",
  "email": "test@example.com",
  "verificationCode": "123456",
  "role": "HR"
}

Response:
{
  "code": 200,
  "message": "操作成功",
  "data": null,
  "timestamp": 1704067200000
}
```

#### 用户登录
```bash
POST /api/v1/auth/login
Content-Type: application/json

{
  "username": "testuser",
  "password": "Password123!"
}

Response:
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 7200,
    "userInfo": {
      "userId": 1,
      "username": "testuser",
      "email": "test@example.com",
      "role": "HR",
      "dailyAiQuota": 100,
      "usedAiQuota": 0
    }
  },
  "timestamp": 1704067200000
}
```

---

**文档生成时间**: 2026-02-15 23:59
**作者**: Claude + NissonCX
**版本**: v1.0
